{"name":"Ruby-JMeter","tagline":"A Ruby based DSL for building JMeter test plans","body":"# RubyJmeter\r\n\r\nTired of using the JMeter GUI or looking at hairy XML files?\r\n\r\nThis gem lets you write test plans for JMeter in your favourite text editor, and optionally run them on [flood.io](http://flood.io). \r\n\r\n## Installation\r\n\r\nInstall it yourself as:\r\n\r\n    $ gem install ruby-jmeter\r\n\r\n## Basic Usage\r\n\r\n*RubyJmeter* exposes easy-to-use domain specific language for fluent communication with [JMeter](http://jmeter.apache.org/).It also includes API integration with [flood.io](https://flood.io), a cloud based load testing service.\r\n\r\nTo use the DSL, first let's require the gem:\r\n\r\n```ruby\r\nrequire 'rubygems'\r\nrequire 'ruby-jmeter'\r\n```\r\n\r\n### Basic Example\r\nLet's create a `test` and save the related `jmx` testplan to file, so we can edit/view it in JMeter.\r\n\r\n```ruby\r\ntest do\r\n  threads count: 10 do\r\n    visit name: 'Google Search', url: 'http://google.com'\r\n  end\r\nend.jmx\r\n```\r\n\r\nSo in this example, we just created a test plan, with 10 threads, each of which visited the search page at Google. \r\n\r\n### Generating a JMeter Test Plan (JMX)\r\nNote also how we called the `jmx` method of the test. Calling this method will write the contents of the JMeter test plan to file like this.\r\n\r\n```\r\n$ ruby testplan.rb\r\n[2013-04-23T10:29:03.275743 #42060]  INFO -- : Test plan saved to: jmeter.jmx\r\n```\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<jmeterTestPlan version=\"1.2\" properties=\"2.1\">\r\n  <hashTree>\r\n    <TestPlan guiclass=\"TestPlanGui\" testclass=\"TestPlan\" testname=\"Test Plan\" enabled=\"true\">\r\n      ...\r\n    </TestPlan>\r\n  </hashTree>\r\n</jmeterTestPlan>\r\nJMX saved to: jmeter.jmx\r\n```\r\n\r\nThe file that is created can then be executed in the JMeter GUI. If you want to create the file with a different filename and/or path, just add the `file` parameter to the `jmx` method call like this.\r\n\r\n```ruby\r\ntest do\r\n  threads count: 10 do\r\n    visit name: 'Google Search', url: 'http://google.com'\r\n  end\r\nend.jmx(file: \"/tmp/my_testplan.jmx\")\r\n```\r\n\r\nWindows users should specify a path like this.\r\n\r\n```ruby\r\n.jmx(file: \"C:\\\\TEMP\\\\MyTestplan.jmx\")\r\n```\r\n\r\n### Running a JMeter Test Plan locally\r\nYou can execute the JMeter test plan by calling the `run` method of the test like this.\r\n\r\n```ruby\r\ntest do\r\n  threads count: 10 do\r\n    visit name: 'Google Search', url: 'http://google.com'\r\n  end\r\nend.run\r\n```\r\n\r\nThis will launch JMeter in headless (non-GUI mode) and execute the test plan. This is useful for shaking out the script before you push it to the Grid. There are a few parameters that you can set such as the `path` to the JMeter binary, the `file` path/name for the JMX file, the `log` path/name to output JMeter logs and the `jtl` path/name for JMeter results like this.\r\n\r\n```ruby\r\ntest do\r\n  threads count: 10 do\r\n    visit name: 'Google Search', url: 'http://google.com'\r\n  end\r\nend.run(\r\n  path: '/usr/share/jmeter/bin/', \r\n  file: 'jmeter.jmx', \r\n  log: 'jmeter.log', \r\n  jtl: 'results.jtl')\r\n```\r\n\r\n### Running a JMeter Test Plan on flood.io\r\n\r\nYou can also execute JMeter test plans on flood.io using our API. To do so, you require an account and API token. If you don't know your token, sign in to [flood.io](https://flood.io/api) and check your account settings.\r\n\r\nTo execute the test on flood.io, call the `grid` method on the test and pass it the API token like this.\r\n\r\n```ruby\r\ntest do  \r\n  threads count: 10 do\r\n    visit name: 'Google Search', url: 'http://google.com'\r\n  end  \r\nend.grid('OxtZ-4v-v0koSz5Y0enEQQ')\r\n```\r\n\r\nThis will then provide you with a link to the live test results on flood.io like this.\r\n\r\n``` \r\nResults at: http://prod.flood.io/shared?testguid=73608030311611e2962f123141011033&run_id=339&tags=jmeter&domain=altentee.com&cluster=54.251.48.129&status=running&view=\r\n```\r\n\r\n## Advanced Usage\r\n\r\n### Blocks\r\n\r\nEach of the methods take an optional block delimited by `do` and `end` or braces `{}`\r\n\r\nBlocks let you nest methods within methods, so you can scope the execution of methods as you would in a normal JMeter test plan. For example.\r\n\r\n```ruby\r\ntest do\r\n  threads count: 100 do\r\n    visit name: 'Home', url: 'http://altentee.com' do\r\n      extract regex: \"content='(.+?)' name='csrf-token'\", name: 'csrf-token'\r\n    end\r\n  end\r\nend\r\n```\r\n\r\nThis would create a new test plan, with a 100 user thread group, each user visiting the \"Home\" page and extracting the CSRF token from the response of each visit.\r\n\r\nAll methods are nestable, but you should only have one test method, and typically only one threads method. For example, it wouldn't make sense to have a test plan within a test plan, or a thread group within a thread group. You can have multiple thread groups per test plan though. This implies *some* knowlege of how JMeter works.\r\n\r\nAll methods take a parameter hash to configure related options.\r\n\r\n### Threads\r\n\r\nYou can use the `threads` method to define a group of users:\r\n\r\n```ruby\r\nthreads count: 100\r\nthreads count: 100, continue_forever: true\r\nthreads count: 100, loops: 10\r\nthreads count: 100, rampup: 30, duration: 60\r\nthreads count: 100, scheduler: true, \r\n  start_time: Time.now.to_i * 1000,\r\n  end_time:   (Time.now.to_i * 1000) + (3600 * 1000)\r\n```\r\n\r\n### Cookies\r\n\r\nYou can use the `cookies` method to define a Cookie Manager:\r\n\r\n```ruby\r\ntest do\r\n  cookies\r\nend\r\n```\r\n\r\nThis methods takes an optional parameters hash. This is based on the [HTTP Cookie Manager](http://jmeter.apache.org/usermanual/component_reference.html#HTTP_Cookie_Manager).\r\n\r\n```ruby\r\ntest do\r\n  cookies clear_each_iteration: false\r\nend\r\n\r\ntest do\r\n  cookies policy: 'rfc2109', clear_each_iteration: true\r\nend\r\n```\r\n\r\n### Cache\r\n\r\nYou can use the `cache` method to define a Cache Manager:\r\n\r\n```ruby\r\ntest do\r\n  cache\r\nend\r\n```\r\n\r\nThis methods takes an optional parameters hash. This is based on the [HTTP Cache Manager](http://jmeter.apache.org/usermanual/component_reference.html#HTTP_Cache_Manager).\r\n\r\n```ruby\r\ntest do\r\n  cache clear_each_iteration: false\r\nend\r\n\r\ntest do\r\n  cache use_expires: true, clear_each_iteration: true\r\nend\r\n```\r\n\r\n### Authorization\r\n\r\nYou can use the `auth` method to define an Authorization Manager:\r\n\r\n```ruby\r\ntest do\r\n  auth\r\nend\r\n```\r\n\r\nThis methods takes an optional parameters hash. This is based on the [HTTP Authorization Manager](http://jmeter.apache.org/usermanual/component_reference.html#HTTP_Authorization_Manager).\r\n\r\n```ruby\r\ntest do\r\n  auth url: '/', username: 'tim', password: 'secret', domain: 'altentee.com'\r\nend\r\n```\r\n\r\n### Navigating\r\n\r\nYou can use the `visit` method to navigate to pages:\r\n\r\n```ruby\r\nvisit name: 'Google Search', url: 'http://google.com'\r\nvisit name: 'Google Search', url: 'http://google.com'\r\nvisit name: 'Google Search', url: 'http://google.com', \r\n  method: 'POST', \r\n  'DO_MULTIPART_POST': 'true'\r\nvisit name: 'Google Search', url: 'http://google.com',\r\n  use_keepalive: 'false'\r\nvisit name: 'Google Search', url: 'http://google.com', \r\n  connect_timeout: '1000',\r\n  response_timeout: '60000'\r\nvisit name: 'View Login', url: '/login', \r\n  protocol: \"https\",\r\n  port: 443\r\n```\r\n\r\n### Submitting a Form\r\n\r\nYou can use the `submit` method to POST a HTTP form:\r\n\r\n```ruby\r\nsubmit name: 'Submit Form', url: 'http://altentee.com/',\r\n  fill_in: {\r\n    username: 'tim',\r\n    password: 'password',\r\n    'csrf-token' => '${csrf-token}'\r\n  }\r\n```\r\n\r\nThis method makes a single request. The fill_in parameter lets you specify key/value pairs for form field parameters. You can also use the built in JMeter `${expression}` language to access run time variables extracted from previous responses.\r\n\r\n### Think Time\r\n\r\nYou can use the `think_time` method to insert pauses into the simulation. This method is aliased as `random_timer`.\r\n\r\n```ruby\r\nthink_time 3000\r\n```\r\n\r\nThis method takes 2 parameters: the constant delay, and an optional variable delay. Both are specified in milliseconds. This is based on the [Gaussian Random Timer](http://jmeter.apache.org/usermanual/component_reference.html#Gaussian_Random_Timer). This timer pauses each thread request for a random amount of time, with most of the time intervals ocurring near a particular value. The total delay is the sum of the Gaussian distributed value (with mean 0.0 and standard deviation 1.0) times the deviation value you specify, and the offset value.\r\n\r\n```ruby\r\n# constant delay of 3 seconds\r\nthink_time 3000\r\n# constant delay of 1 seconds with variance up to 6 seconds.\r\nrandom_timer 1000,5000\r\n```\r\n\r\n### Response Extractor\r\n\r\nYou can use the `extract` method to extract values from a server response using a regular expression. This is aliased as the `web_reg_save_param` method. This method is typically used inside a `visit` or `submit` block.\r\n\r\n```ruby\r\nextract regex: \"content='(.+?)' name='csrf-token'\", name: 'csrf-token'\r\n\r\nvisit name: 'Google', url: \"http://google.com/\" do\r\n  extract regex: 'aria-label=\"(.+?)\"', name: 'button_text'\r\n  extract xpath: '//button', name: 'button'\r\nend\r\n```\r\n\r\nThis is based on the [Regular Expression Extractor](http://jmeter.apache.org/usermanual/component_reference.html#Regular_Expression_Extractor) and [XPath Extractor](http://jmeter.apache.org/usermanual/component_reference.html#XPath_Extractor)\r\n\r\n```ruby\r\nvisit name: \"Altentee\", url: \"http://altentee.com\" do\r\n  extract regex: \"content='(.+?)' name='csrf-token'\", name: 'csrf-token'\r\n  extract regex: 'value=\"(.+?)\" name=\"JESSIONSID\"', name: 'JSESSIONID'\r\n  web_reg_save_param regex: 'value=\"(.+?)\" name=\"VIEWSTATE\"', name: 'VIEWSTATE'\r\n  extract name: 'username', regex: 'value=\"(.+?)\", name=\"username\"', \r\n    default: 'Tim Koopmans',\r\n    match_number: 1\r\n  extract name: 'shopping_item', regex: 'id=\"(.+?)\" name=\"book\"', \r\n    match_number: 0 # random\r\nend\r\n```\r\n\r\n### Response Assertion\r\n\r\nYou can use the `assert` method to extract values from a server response using a regular expression. This is aliased as the `web_reg_find` method. This method is typically used inside a `visit` or `submit` block.\r\n\r\n```ruby\r\nvisit \"Altentee\", \"http://altentee.com\" do\r\n  assert contains: \"We test, tune and secure your site\"\r\nend\r\n```\r\n\r\n\r\nThis method takes 3 parameters: the matching rule, the test string, and an optional parameters hash. This is based on the [Response Assertion](http://jmeter.apache.org/usermanual/component_reference.html#Response_Assertion). \r\n\r\n```ruby\r\nvisit \"Altentee\", \"http://altentee.com\" do\r\n  assert \"contains\": \"We test, tune and secure your site\"\r\n  assert \"not-contains\": \"We price gouge on cloud services\"\r\n  assert \"matches\": \"genius\"\r\n  assert \"not-matches\": \"fakers\"\r\n  assert \"contains\": \"magic\"\r\n  assert \"not-contains\": \"unicorns\", scope: 'all'\r\nend\r\n```\r\n\r\n## Roadmap\r\n\r\nThis work is being sponsored by flood.io. Get in touch with us if you'd like to be involved.\r\n\r\n## Contributing\r\n\r\n1. Fork it\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Create some specs, make them pass\r\n4. Commit your changes (`git commit -am 'Add some feature'`)\r\n5. Push to the branch (`git push origin my-new-feature`)\r\n6. Create new Pull Request\r\n","google":"UA-42892720-2","note":"Don't delete this file! It's used internally to help with page regeneration."}